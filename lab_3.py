# -*- coding: utf-8 -*-
"""Lab_3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Zl1kvhOnyEy0FK5qOBARHpy0egGEZ-3-
"""

from collections import deque

pakistan_cities = {
    'Islamabad': ['Rawalpindi'],
    'Rawalpindi': ['Haripur', 'Texila'],
    'Texila': ['Haripur', 'Manshera', 'Abbottabad'],
    'Abbottabad': ['Nathigali', 'Naran'],
    'Naran': ['Gilgit'],
    'Gilgit': ['Skardu', 'Kashmir'],
    'Kashmir': ['Jammu and Kashmir', 'Muree'],
    'Muree': ['Islamabad']
}

# create function with three parameters
def bfs(graph, start, goal):
    # create deque for addition and deletion for both side
    queue = deque([[start]])

    # now we create a variable where i can store visited node
    visited = set()

    # now i start a loop where he it can check every node and give me desired search result
    while queue:
        # at here i pop first element which enters first (fifo)
        path = queue.popleft()
        # get node where i am right now
        current_city = path[-1]

        # at here i finally gets my goal
        if current_city == goal:
            return path

        # if the current city not visited yet than mark visited
        if current_city not in visited:
            visited.add(current_city)

            # at here we just get the neighbor of the main node if found then return if not just simply get empty
            for neighbor in graph.get(current_city, []):
                # create new path where ii can get copy of current path
                new_path = list(path)
                # at here add neighbor city in path
                new_path.append(neighbor)

                # now add this in queue to explore next
                queue.append(new_path)

    # at here you dont find goal and queue is empty then return none
    return None


def dfs_path(graph, start, goal, path=None, visited=None):
    # if dont have path argument just simply create it
    if path is None:
        path = []

    # if visited argument not found then create empty set
    if visited is None:
        visited = set()

    # Start city add in path and create visited mark
    path.append(start)
    visited.add(start)

    # if start city is the goal city ,then return a path
    if start == goal:
        return path

    ## explore every neighbor recursively
    for neighbor in graph.get(start, []):
        if neighbor not in visited:
            result = dfs_path(graph, neighbor, goal, path.copy(), visited.copy())
            # if find goal then simply return goal
            if result:
                return result
    # if not found then simply return
    return None


# now test the function

start_city = "Naran"
goal_city = "Gilgit"     # Capital G fix kiya taaki dictionary key se match kare

bfs_result = bfs(pakistan_cities, start_city, goal_city)
print("BFS Shortest Path from Naran to Gilgit:", bfs_result)

dfs_result = dfs_path(pakistan_cities, start_city, goal_city)
print("DFS Path from Naran to Gilgit:", dfs_result)

